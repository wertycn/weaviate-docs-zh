---
authors:
- abdel
date: 2022-10-11
description: 'Vector search on disks: How does Vamana compare to HNSW?'
image: ./img/hero.png
slug: ann-algorithms-vamana-vs-hnsw
tags:
- research
title: Vamana vs. HNSW - Exploring ANN algorithms Part 1
---

![Vamana vs HNSW - 探索ANN算法第一部分](./img/hero.png)

<!-- 省略部分 -->

矢量数据库必须能够快速搜索大量的向量。随着向量维度和数据集大小的增加，这是一个巨大的技术挑战，难度还在不断增加。

像许多其他解决方案一样，我们目前主要使用近似最近邻（ANN）算法来支持Weaviate。但关键问题是 - 应该使用哪种算法？有许多不同的ANN算法，每种算法都有不同的优点和限制。

### 大规模应用
当我们谈论大量对象时，如今我们经常看到使用数亿个向量的用例，但很快会出现数十亿甚至数万亿的标准用例。

要实现这种规模的向量数据库，我们需要不断发展并寻找更高效的解决方案。在这个搜索过程中，我们的一大部分工作是探索ANN算法，以便在不牺牲性能和用户体验的情况下突破可用的RAM（这是一个瓶颈）。

### 期望的结果
在这一系列的博客文章中，我们将带领您与我们一同进行研究和实现新的ANN算法，以实现我们达到1T目标的愿景。

在本文中，我们将介绍磁盘解决方案的需求，探讨Vamana（它的工作原理并与HNSW进行对比），并呈现Vamana实现的结果。

> 如果您对向量数据库和ANN还不熟悉，我建议您阅读"[为什么向量搜索如此快？](/blog/why-is-vector-search-so-fast)"。<br/>
> 这篇文章解释了什么是向量数据库以及它们的工作原理。

## 近似搜索的需求
为了使向量数据库能够高效地搜索大量向量，数据库需要具备智能化的能力。一种蛮力的方法是计算查询向量与查询集合中每个数据向量之间的距离，但这在计算上非常昂贵。对于具有数百万个对象和成千上万个高维向量的数据库来说，这将花费太长时间。

[Weaviate](/developers/weaviate/)是一个用Go语言编写的开源向量数据库，可以每秒处理数千个查询。在[Sift1M](https://www.tensorflow.org/datasets/catalog/sift1m)上运行Weaviate（一个128维对象表示）可以让您以个位数毫秒的速度处理查询。但是这是如何实现的呢？

![SIFT1M基准测试示例](./img/SIFT1M-benchmark.png)
*请参阅[基准测试](/developers/weaviate/benchmarks/ann)页面获取更多统计信息。*

Weaviate在存储中不会寻找完全最近的向量。相反，它寻找近似（足够接近）的元素。这意味着您可能会得到更快的回复，但不能保证您实际上会得到与搜索最接近的元素。在向量搜索空间中，我们使用[召回率](https://en.wikipedia.org/wiki/Precision_and_recall)来衡量返回预期匹配的比率。召回率和延迟之间的权衡可以通过调整索引参数来进行调整。Weaviate具有合理的默认值，但也允许您调整构建和查询时间参数以找到合适的平衡点。

Weaviate会逐步建立一个索引（向量及其最近邻的图表示），每当有新的对象进入时。然后当查询到达时，Weaviate会遍历索引，在比暴力方法更短的时间内获得对查询的良好近似答案。

[HNSW](/developers/weaviate/concepts/vector-index#hnsw) 是我们在 Weaviate 中实现的第一个可用于生产的索引算法。它是一种稳健且高效的算法，可以在内存中构建索引的分层表示，以便快速查找查询向量的 k 个最近邻居。

## 对磁盘解决方案的需求
还有其他需要克服的挑战。数据库增长如此之快，以至于即使使用上述描述的算法也不足够。我们不再谈论成千上万的向量，而是**亿计甚至十亿计**！将所有向量保存在内存中，并添加一个向量连接的图形表示，**需要大量的内存**。这促使出现了一组新的算法，可以使向量存储在磁盘而不是内存中，同时保持高性能。

一些著名的基于磁盘的解决方案包括[DiskANN](https://proceedings.neurips.cc/paper/2019/file/09853c7fb1d3f8ee67a61b6bf4a7f8e6-Paper.pdf)和[SPANN](https://arxiv.org/abs/2111.08566)。

## Weaviate的未来
如今，用户在生产环境中使用Weaviate为大规模用例提供服务，具有以个位数毫秒的延迟和大规模吞吐量。但并非每个用例都需要如此高的吞吐量，以至于保持所有索引在内存中的成本是合理的。如果您有一个大规模的数据集，但查询非常少，如果成本效益更重要而不是最低可能的延迟，那该怎么办呢？

我们相信除了经过实践验证的HNSW实现之外，还需要其他类型的索引。但是，成本效益永远不能成为牺牲用户体验的理由。因此，我们正在努力建立一种新型的向量索引，将基于SSD的解决方案的低运营成本与现有内存解决方案的易用性相结合。

在Weaviate，我们以我们的研究能力和提供最先进的解决方案为荣。因此，我们花费了时间来探索这些解决方案，以识别和评估Weaviate未来的正确构建模块。在这里，我们分享了我们从这项研究中得出的一些发现。

## 关于HNSW和Vamana的比较
作为基于磁盘的向量索引的第一步，我们决定探索Vamana - DiskANN解决方案背后的算法。以下是Vamana和HNSW之间的一些关键区别：

### Vamana索引 - 简介:
* 构建一个随机图形。
* 优化图形，使其仅连接彼此接近的向量。
* 通过删除一些短连接并添加一些长距离边缘来修改图形，以加快图形的遍历。

### HNSW索引 - 简介:
* 构建一个层次结构，以加快最近邻图的遍历。
* 在该图中，顶层仅包含长距离边缘。
* 搜索在层次结构中深入遍历的程度越深，边缘捕获的向量之间的距离就越短。

简单来说，Vamana可以构建一个扁平的图形，与使用分层表示的HNSW相对应。而扁平图形在存储在磁盘上时可能遭受的性能降低较少，而分层表示可能会遭受较多。原因是由于我们可以知道每个节点的出站连接，所以可以以一种可以在检索给定节点的邻居信息时计算出精确位置的方式存储信息。这使得信息检索过程非常高效，因此磁盘存储所带来的较低速度问题变得不那么严重。

HNSW使用的层次表示的主要优势是加速图的遍历。Vamana实现通过使用类似的功能来托管长距离连接来解决这个问题。

### 遍历图
遍历图形有点像计划国际旅行。首先，我们可以乘坐长途飞机（类似于快速跳跃），将我们带到离目的地更近的城市。然后，我们可以乘坐火车（对环境更友好😉）到达我们选择的小镇。最后，我们可以骑自行车到达我们的目的地。

为了更好地理解，考虑下面的图形，它显示了一个包含1000个二维对象的图形中生成的所有连接。

<img
    src={require('./img/vamana-graph.png').default}
    alt="Vamana graph with 1000 objects"
    style={{ maxWidth: "50%" }}
/>

如果我们按步骤迭代它，我们可以分析Vamana如何在图中导航。

<img
    src={require('./img/vamana-graph-animated.gif').default}
    alt="Vamana graph - animated in 3/6/9 steps"
    style={{ maxWidth: "50%" }}
/>

在**第一步**中，您可以看到搜索的入口点位于中心，然后通过长距离连接可以跳转到边缘。这意味着当查询到来时，它会快速朝着适当的方向移动。<br/>
**第二步**，**第三步**和**最后一步**突出显示了从入口节点可达的**三个**、**六个**和**九个**跳的节点。

HNSW则以稍微不同的方式实现了相同的思想。它不是将所有信息放在一个平面图上，而是将信息分布在多个层次结构中。顶层只包含长距离连接，当您深入到更深层次时，您的查询会被路由到适当的区域，在那里您可以在更局部的范围内查找答案。因此，您的搜索从顶层开始只进行大幅度的跳跃，直到最后在底层局部区域查找最接近的点。

## 性能比较
那么，它们的性能如何？让我们从速度和召回率两方面来看一下。

下面的图表对比了使用Sift1M数据集时，微软提供的C++ Vamana[参考代码](https://github.com/microsoft/DiskANN)和我们的[HNSW实现](https://github.com/weaviate/weaviate/tree/master/adapters/repos/db/vector/hnsw)。根据微软的实验，我们使用了sift-query.fvecs（100,000个向量样本）来构建索引，使用sift-query.fvecs（1,000个向量样本）进行查询。我们每次查询检索10个**(图1)**和100个**(图2)**对象。图表显示了在微软使用的相同Google Cloud环境下的召回率与延迟之间的关系。在这两种情况下，您可能会注意到Vamana和HNSW实现的性能相似。

*请记住，在DiskANN中使用的是Vamana算法，但在此阶段，我们将在内存中比较这两种解决方案。*

![检索十个近似最近邻时的召回率与延迟](./img/fig-1.png)
*图1：检索十个近似最近邻时的召回率与延迟。*

![检索一百个近似最近邻时的召回率与延迟](./img/fig-2.png)
*图2：检索一百个近似最近邻时的召回率与延迟。*

## Vamana实现细节
我们在Weaviate中还包含了Vamana索引算法的开发实现。为了使算法能够良好运行，这样的实现需要仔细注意代码的优化。来自Microsoft的原始算法基于贪婪搜索和强大的修剪方法，在[DiskANN论文](https://proceedings.neurips.cc/paper/2019/file/09853c7fb1d3f8ee67a61b6bf4a7f8e6-Paper.pdf)中描述如下:

![Vamana算法](./img/vamana-algorithm.png)

### 用简单的英语解释
这些伪代码片段通常很难阅读，所以这里用简单的英语解释一下Vamana算法的工作原理。

贪婪搜索算法用于查找查询的解决方案。主要思想是从入口点开始迭代地寻找最佳点。算法通过维护一个结果集合来保存点，从入口点开始。

在每次迭代中，它会检查尚未访问过的结果集中的点，并从中选择最佳候选点（最接近查询点的点），然后对其进行探索。在这个上下文中，探索的意思是将候选点（邻居节点）从图中添加到结果集，并将其标记为已访问。请注意，结果集的大小必须保持有界，所以每当它增长得太多时，我们只保留那些距离查询点更近的L个点。结果集的最大大小越大，结果越准确，搜索速度越慢。当当前集合中的所有点都被访问并返回前k个结果时，我们停止搜索。

另一方面，鲁棒修剪方法在特定点p上优化图形，以使贪婪搜索运行更快。为此，它检查一个已访问节点的列表，并在每次迭代中选择一个点，该点使得与p（我们当前正在优化图形的节点）的距离最小，并将其添加到节点p的出邻居中。它还删除可以从新添加的节点到达的节点，其距离比从p到达的距离短（通过alpha放大以保持长程连接）。

这两个算法的结合应该能够实现高召回率的快速搜索。

### 实现观察

我们最初按照描述实现了Vamana算法，得到了非常好的召回结果。然而，延迟并不理想。我们后来意识到性能下降是由于许多集合操作导致算法的性能不佳。

在我们的改进实现中，我们对算法进行了一些修改，将访问过的节点和当前节点的副本保存在一个单一的排序列表中。此外，随着参数L的增长，对集合的搜索变得更加昂贵，因此我们已经决定将集合中的向量采用基于位的表示方式，这在性能方面产生了巨大的影响。仅凭这些改变，我们就实现了接近于微软实现的性能，如**(图3)**和**(图4)**所示。请注意，微软的实现是用C++编写的，而我们的实现是用Go语言编写的。

我们评估了不同的数据结构，并通过以下方式实现了最佳性能：
* 保持一个基于排序的数组集合。
* 使插入操作使用二分搜索。
* 使从Go到内存的复制函数移动完整的内存部分。

![检索十个近似最近邻居时的召回率与延迟](./img/fig-3.png)
*图3：检索十个近似最近邻居时的召回率与延迟。*

![检索一百个近似最近邻居时的召回率与延迟](./img/fig-4.png)
*图4：检索100个近似最近邻时的召回率与延迟对比。*

## 那么，SSD何时起作用？
但是，请等一下，这就是结局吗？迁移到磁盘不是最终目标吗？我们还在内存中，不是吗？
不用担心。这只是向目标迈出的第一步。我们希望在迁移到磁盘之前，确保我们在内存中有一个稳定的实现，而这个里程碑就到此为止。

:::note
!Spoilers alert, as you read this article, we are evaluating our implementation on disk.<br/>
We will prepare a similar article to outline; how we moved everything to disk and what the price was performance-wise.
:::

## 结论
我们已经成功在DiskANN上实现了索引算法，并且性能表现良好。

经过多年的研究和开发，Weaviate拥有高度优化的HNSW算法实现。通过Vamana实现，我们获得了可比较的内存结果。

还有一些挑战需要克服和问题需要回答。例如：
* 我们应该如何继续进行Weaviate的自然磁盘解决方案？
* 应该只是实现DiskANN吗？
* 或者我们应该探索HNSW的能力并调整它以在磁盘上工作？
* 我们如何在享受基于磁盘的解决方案的好处的同时，确保卓越的数据库用户体验，这对许多Weaviate用户来说非常宝贵？

请继续关注，我们将探索这些挑战和问题。我们将在探索过程中分享我们的见解。 😀 <br/>
保持联系，并定期查看[我们的博客](/blog)。

import WhatNext from '/_includes/what-next.mdx'

<WhatNext />